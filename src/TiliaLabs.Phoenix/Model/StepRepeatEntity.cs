/* 
 * tilia Phoenix API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 7.0.6
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = TiliaLabs.Phoenix.Client.SwaggerDateConverter;

namespace TiliaLabs.Phoenix.Model
{
    /// <summary>
    /// Step and Repeat parameters
    /// </summary>
    [DataContract]
        public partial class StepRepeatEntity :  IEquatable<StepRepeatEntity>, IValidatableObject
    {
        /// <summary>
        /// Head turn rotation to apply on every other row and/or column
        /// </summary>
        /// <value>Head turn rotation to apply on every other row and/or column</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum HeadTurnEnum
        {
            /// <summary>
            /// Enum None for value: None
            /// </summary>
            [EnumMember(Value = "None")]
            None = 1,
            /// <summary>
            /// Enum Column for value: Column
            /// </summary>
            [EnumMember(Value = "Column")]
            Column = 2,
            /// <summary>
            /// Enum Row for value: Row
            /// </summary>
            [EnumMember(Value = "Row")]
            Row = 3,
            /// <summary>
            /// Enum ColumnRow for value: ColumnRow
            /// </summary>
            [EnumMember(Value = "ColumnRow")]
            ColumnRow = 4        }
        /// <summary>
        /// Head turn rotation to apply on every other row and/or column
        /// </summary>
        /// <value>Head turn rotation to apply on every other row and/or column</value>
        [DataMember(Name="head-turn", EmitDefaultValue=false)]
        public HeadTurnEnum? HeadTurn { get; set; }
        /// <summary>
        /// Horizontal gap type defining how horizontal gap(s) are interpreted.  Default: Edge
        /// </summary>
        /// <value>Horizontal gap type defining how horizontal gap(s) are interpreted.  Default: Edge</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum HorizontalGapTypeEnum
        {
            /// <summary>
            /// Enum Center for value: Center
            /// </summary>
            [EnumMember(Value = "Center")]
            Center = 1,
            /// <summary>
            /// Enum Edge for value: Edge
            /// </summary>
            [EnumMember(Value = "Edge")]
            Edge = 2,
            /// <summary>
            /// Enum Smart for value: Smart
            /// </summary>
            [EnumMember(Value = "Smart")]
            Smart = 3        }
        /// <summary>
        /// Horizontal gap type defining how horizontal gap(s) are interpreted.  Default: Edge
        /// </summary>
        /// <value>Horizontal gap type defining how horizontal gap(s) are interpreted.  Default: Edge</value>
        [DataMember(Name="horizontal-gap-type", EmitDefaultValue=false)]
        public HorizontalGapTypeEnum? HorizontalGapType { get; set; }
        /// <summary>
        /// Vertical gap type defining how vertical gap(s) are interpreted.  Default: Edge
        /// </summary>
        /// <value>Vertical gap type defining how vertical gap(s) are interpreted.  Default: Edge</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum VerticalGapTypeEnum
        {
            /// <summary>
            /// Enum Center for value: Center
            /// </summary>
            [EnumMember(Value = "Center")]
            Center = 1,
            /// <summary>
            /// Enum Edge for value: Edge
            /// </summary>
            [EnumMember(Value = "Edge")]
            Edge = 2,
            /// <summary>
            /// Enum Smart for value: Smart
            /// </summary>
            [EnumMember(Value = "Smart")]
            Smart = 3        }
        /// <summary>
        /// Vertical gap type defining how vertical gap(s) are interpreted.  Default: Edge
        /// </summary>
        /// <value>Vertical gap type defining how vertical gap(s) are interpreted.  Default: Edge</value>
        [DataMember(Name="vertical-gap-type", EmitDefaultValue=false)]
        public VerticalGapTypeEnum? VerticalGapType { get; set; }
        /// <summary>
        /// Type of stagger to apply to rows or columns.  If not specified no stagger is applied.
        /// </summary>
        /// <value>Type of stagger to apply to rows or columns.  If not specified no stagger is applied.</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum StaggerEnum
        {
            /// <summary>
            /// Enum None for value: None
            /// </summary>
            [EnumMember(Value = "None")]
            None = 1,
            /// <summary>
            /// Enum Horizontal for value: Horizontal
            /// </summary>
            [EnumMember(Value = "Horizontal")]
            Horizontal = 2,
            /// <summary>
            /// Enum Vertical for value: Vertical
            /// </summary>
            [EnumMember(Value = "Vertical")]
            Vertical = 3        }
        /// <summary>
        /// Type of stagger to apply to rows or columns.  If not specified no stagger is applied.
        /// </summary>
        /// <value>Type of stagger to apply to rows or columns.  If not specified no stagger is applied.</value>
        [DataMember(Name="stagger", EmitDefaultValue=false)]
        public StaggerEnum? Stagger { get; set; }
        /// <summary>
        /// Whether to automatically fill the sheet as much as possible in the horizontal direction.  By default horizontal-fill is off (None) in which case the columns field needs to be defined.
        /// </summary>
        /// <value>Whether to automatically fill the sheet as much as possible in the horizontal direction.  By default horizontal-fill is off (None) in which case the columns field needs to be defined.</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum HorizontalFillEnum
        {
            /// <summary>
            /// Enum None for value: None
            /// </summary>
            [EnumMember(Value = "None")]
            None = 1,
            /// <summary>
            /// Enum Pack for value: Pack
            /// </summary>
            [EnumMember(Value = "Pack")]
            Pack = 2,
            /// <summary>
            /// Enum Expand for value: Expand
            /// </summary>
            [EnumMember(Value = "Expand")]
            Expand = 3,
            /// <summary>
            /// Enum Wrap for value: Wrap
            /// </summary>
            [EnumMember(Value = "Wrap")]
            Wrap = 4        }
        /// <summary>
        /// Whether to automatically fill the sheet as much as possible in the horizontal direction.  By default horizontal-fill is off (None) in which case the columns field needs to be defined.
        /// </summary>
        /// <value>Whether to automatically fill the sheet as much as possible in the horizontal direction.  By default horizontal-fill is off (None) in which case the columns field needs to be defined.</value>
        [DataMember(Name="horizontal-fill", EmitDefaultValue=false)]
        public HorizontalFillEnum? HorizontalFill { get; set; }
        /// <summary>
        /// Whether to automatically fill the sheet as much as possible in the vertical direction.  By default horizontal-fill is off (None) in which case the rows field needs to be defined.
        /// </summary>
        /// <value>Whether to automatically fill the sheet as much as possible in the vertical direction.  By default horizontal-fill is off (None) in which case the rows field needs to be defined.</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum VerticalFillEnum
        {
            /// <summary>
            /// Enum None for value: None
            /// </summary>
            [EnumMember(Value = "None")]
            None = 1,
            /// <summary>
            /// Enum Pack for value: Pack
            /// </summary>
            [EnumMember(Value = "Pack")]
            Pack = 2,
            /// <summary>
            /// Enum Expand for value: Expand
            /// </summary>
            [EnumMember(Value = "Expand")]
            Expand = 3,
            /// <summary>
            /// Enum Wrap for value: Wrap
            /// </summary>
            [EnumMember(Value = "Wrap")]
            Wrap = 4        }
        /// <summary>
        /// Whether to automatically fill the sheet as much as possible in the vertical direction.  By default horizontal-fill is off (None) in which case the rows field needs to be defined.
        /// </summary>
        /// <value>Whether to automatically fill the sheet as much as possible in the vertical direction.  By default horizontal-fill is off (None) in which case the rows field needs to be defined.</value>
        [DataMember(Name="vertical-fill", EmitDefaultValue=false)]
        public VerticalFillEnum? VerticalFill { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="StepRepeatEntity" /> class.
        /// </summary>
        /// <param name="rows">Number of rows in step and repeat grid when vertical-fill is not set or is None.</param>
        /// <param name="columns">Number of columns in step and repeat grid when horizontal-fill is not set or is None.</param>
        /// <param name="headTurn">Head turn rotation to apply on every other row and/or column.</param>
        /// <param name="initialRotation">Initial rotation to apply to product when building step and repeat grid.</param>
        /// <param name="horizontalGapType">Horizontal gap type defining how horizontal gap(s) are interpreted.  Default: Edge.</param>
        /// <param name="verticalGapType">Vertical gap type defining how vertical gap(s) are interpreted.  Default: Edge.</param>
        /// <param name="horizontalGap">Horizontal gap scalar value (required).</param>
        /// <param name="verticalGap">Vertical gap scalar value (required).</param>
        /// <param name="evenHorizontalGap">Optional even horizontal gap scalar value.  When set, horizontal-gap is used for odd horizontal gap spacing while this gap value is used for even rows.</param>
        /// <param name="evenVerticalGap">Optional even vertical gap scalar value.  When set, vertical-gap is used for odd vertical gap spacing while this gap value is used for even rows.</param>
        /// <param name="stagger">Type of stagger to apply to rows or columns.  If not specified no stagger is applied..</param>
        /// <param name="staggerAmount">Stagger amount when stagger is not None.</param>
        /// <param name="staggerRestart">Number of rows or columns before stagger amount is restarted back to 0.  If not defined, stagger value continues to be applied to each subsequent row or column indefinitely..</param>
        /// <param name="horizontalFill">Whether to automatically fill the sheet as much as possible in the horizontal direction.  By default horizontal-fill is off (None) in which case the columns field needs to be defined..</param>
        /// <param name="verticalFill">Whether to automatically fill the sheet as much as possible in the vertical direction.  By default horizontal-fill is off (None) in which case the rows field needs to be defined..</param>
        /// <param name="sheetMargins">sheetMargins.</param>
        /// <param name="bleedOffset">When set, a bleed offset is applied to each product in the step and repeat group and rectangular bleeds are automatically resolved.  If not set, product bleed masks are used..</param>
        public StepRepeatEntity(int? rows = default(int?), int? columns = default(int?), HeadTurnEnum? headTurn = default(HeadTurnEnum?), double? initialRotation = default(double?), HorizontalGapTypeEnum? horizontalGapType = default(HorizontalGapTypeEnum?), VerticalGapTypeEnum? verticalGapType = default(VerticalGapTypeEnum?), string horizontalGap = default(string), string verticalGap = default(string), string evenHorizontalGap = default(string), string evenVerticalGap = default(string), StaggerEnum? stagger = default(StaggerEnum?), string staggerAmount = default(string), int? staggerRestart = default(int?), HorizontalFillEnum? horizontalFill = default(HorizontalFillEnum?), VerticalFillEnum? verticalFill = default(VerticalFillEnum?), MarginsEntity sheetMargins = default(MarginsEntity), string bleedOffset = default(string))
        {
            // to ensure "horizontalGap" is required (not null)
            if (horizontalGap == null)
            {
                throw new InvalidDataException("horizontalGap is a required property for StepRepeatEntity and cannot be null");
            }
            else
            {
                this.HorizontalGap = horizontalGap;
            }
            // to ensure "verticalGap" is required (not null)
            if (verticalGap == null)
            {
                throw new InvalidDataException("verticalGap is a required property for StepRepeatEntity and cannot be null");
            }
            else
            {
                this.VerticalGap = verticalGap;
            }
            this.Rows = rows;
            this.Columns = columns;
            this.HeadTurn = headTurn;
            this.InitialRotation = initialRotation;
            this.HorizontalGapType = horizontalGapType;
            this.VerticalGapType = verticalGapType;
            this.EvenHorizontalGap = evenHorizontalGap;
            this.EvenVerticalGap = evenVerticalGap;
            this.Stagger = stagger;
            this.StaggerAmount = staggerAmount;
            this.StaggerRestart = staggerRestart;
            this.HorizontalFill = horizontalFill;
            this.VerticalFill = verticalFill;
            this.SheetMargins = sheetMargins;
            this.BleedOffset = bleedOffset;
        }
        
        /// <summary>
        /// Number of rows in step and repeat grid when vertical-fill is not set or is None
        /// </summary>
        /// <value>Number of rows in step and repeat grid when vertical-fill is not set or is None</value>
        [DataMember(Name="rows", EmitDefaultValue=false)]
        public int? Rows { get; set; }

        /// <summary>
        /// Number of columns in step and repeat grid when horizontal-fill is not set or is None
        /// </summary>
        /// <value>Number of columns in step and repeat grid when horizontal-fill is not set or is None</value>
        [DataMember(Name="columns", EmitDefaultValue=false)]
        public int? Columns { get; set; }


        /// <summary>
        /// Initial rotation to apply to product when building step and repeat grid
        /// </summary>
        /// <value>Initial rotation to apply to product when building step and repeat grid</value>
        [DataMember(Name="initial-rotation", EmitDefaultValue=false)]
        public double? InitialRotation { get; set; }



        /// <summary>
        /// Horizontal gap scalar value
        /// </summary>
        /// <value>Horizontal gap scalar value</value>
        [DataMember(Name="horizontal-gap", EmitDefaultValue=false)]
        public string HorizontalGap { get; set; }

        /// <summary>
        /// Vertical gap scalar value
        /// </summary>
        /// <value>Vertical gap scalar value</value>
        [DataMember(Name="vertical-gap", EmitDefaultValue=false)]
        public string VerticalGap { get; set; }

        /// <summary>
        /// Optional even horizontal gap scalar value.  When set, horizontal-gap is used for odd horizontal gap spacing while this gap value is used for even rows
        /// </summary>
        /// <value>Optional even horizontal gap scalar value.  When set, horizontal-gap is used for odd horizontal gap spacing while this gap value is used for even rows</value>
        [DataMember(Name="even-horizontal-gap", EmitDefaultValue=false)]
        public string EvenHorizontalGap { get; set; }

        /// <summary>
        /// Optional even vertical gap scalar value.  When set, vertical-gap is used for odd vertical gap spacing while this gap value is used for even rows
        /// </summary>
        /// <value>Optional even vertical gap scalar value.  When set, vertical-gap is used for odd vertical gap spacing while this gap value is used for even rows</value>
        [DataMember(Name="even-vertical-gap", EmitDefaultValue=false)]
        public string EvenVerticalGap { get; set; }


        /// <summary>
        /// Stagger amount when stagger is not None
        /// </summary>
        /// <value>Stagger amount when stagger is not None</value>
        [DataMember(Name="stagger-amount", EmitDefaultValue=false)]
        public string StaggerAmount { get; set; }

        /// <summary>
        /// Number of rows or columns before stagger amount is restarted back to 0.  If not defined, stagger value continues to be applied to each subsequent row or column indefinitely.
        /// </summary>
        /// <value>Number of rows or columns before stagger amount is restarted back to 0.  If not defined, stagger value continues to be applied to each subsequent row or column indefinitely.</value>
        [DataMember(Name="stagger-restart", EmitDefaultValue=false)]
        public int? StaggerRestart { get; set; }



        /// <summary>
        /// Gets or Sets SheetMargins
        /// </summary>
        [DataMember(Name="sheet-margins", EmitDefaultValue=false)]
        public MarginsEntity SheetMargins { get; set; }

        /// <summary>
        /// When set, a bleed offset is applied to each product in the step and repeat group and rectangular bleeds are automatically resolved.  If not set, product bleed masks are used.
        /// </summary>
        /// <value>When set, a bleed offset is applied to each product in the step and repeat group and rectangular bleeds are automatically resolved.  If not set, product bleed masks are used.</value>
        [DataMember(Name="bleed-offset", EmitDefaultValue=false)]
        public string BleedOffset { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class StepRepeatEntity {\n");
            sb.Append("  Rows: ").Append(Rows).Append("\n");
            sb.Append("  Columns: ").Append(Columns).Append("\n");
            sb.Append("  HeadTurn: ").Append(HeadTurn).Append("\n");
            sb.Append("  InitialRotation: ").Append(InitialRotation).Append("\n");
            sb.Append("  HorizontalGapType: ").Append(HorizontalGapType).Append("\n");
            sb.Append("  VerticalGapType: ").Append(VerticalGapType).Append("\n");
            sb.Append("  HorizontalGap: ").Append(HorizontalGap).Append("\n");
            sb.Append("  VerticalGap: ").Append(VerticalGap).Append("\n");
            sb.Append("  EvenHorizontalGap: ").Append(EvenHorizontalGap).Append("\n");
            sb.Append("  EvenVerticalGap: ").Append(EvenVerticalGap).Append("\n");
            sb.Append("  Stagger: ").Append(Stagger).Append("\n");
            sb.Append("  StaggerAmount: ").Append(StaggerAmount).Append("\n");
            sb.Append("  StaggerRestart: ").Append(StaggerRestart).Append("\n");
            sb.Append("  HorizontalFill: ").Append(HorizontalFill).Append("\n");
            sb.Append("  VerticalFill: ").Append(VerticalFill).Append("\n");
            sb.Append("  SheetMargins: ").Append(SheetMargins).Append("\n");
            sb.Append("  BleedOffset: ").Append(BleedOffset).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as StepRepeatEntity);
        }

        /// <summary>
        /// Returns true if StepRepeatEntity instances are equal
        /// </summary>
        /// <param name="input">Instance of StepRepeatEntity to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(StepRepeatEntity input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Rows == input.Rows ||
                    (this.Rows != null &&
                    this.Rows.Equals(input.Rows))
                ) && 
                (
                    this.Columns == input.Columns ||
                    (this.Columns != null &&
                    this.Columns.Equals(input.Columns))
                ) && 
                (
                    this.HeadTurn == input.HeadTurn ||
                    (this.HeadTurn != null &&
                    this.HeadTurn.Equals(input.HeadTurn))
                ) && 
                (
                    this.InitialRotation == input.InitialRotation ||
                    (this.InitialRotation != null &&
                    this.InitialRotation.Equals(input.InitialRotation))
                ) && 
                (
                    this.HorizontalGapType == input.HorizontalGapType ||
                    (this.HorizontalGapType != null &&
                    this.HorizontalGapType.Equals(input.HorizontalGapType))
                ) && 
                (
                    this.VerticalGapType == input.VerticalGapType ||
                    (this.VerticalGapType != null &&
                    this.VerticalGapType.Equals(input.VerticalGapType))
                ) && 
                (
                    this.HorizontalGap == input.HorizontalGap ||
                    (this.HorizontalGap != null &&
                    this.HorizontalGap.Equals(input.HorizontalGap))
                ) && 
                (
                    this.VerticalGap == input.VerticalGap ||
                    (this.VerticalGap != null &&
                    this.VerticalGap.Equals(input.VerticalGap))
                ) && 
                (
                    this.EvenHorizontalGap == input.EvenHorizontalGap ||
                    (this.EvenHorizontalGap != null &&
                    this.EvenHorizontalGap.Equals(input.EvenHorizontalGap))
                ) && 
                (
                    this.EvenVerticalGap == input.EvenVerticalGap ||
                    (this.EvenVerticalGap != null &&
                    this.EvenVerticalGap.Equals(input.EvenVerticalGap))
                ) && 
                (
                    this.Stagger == input.Stagger ||
                    (this.Stagger != null &&
                    this.Stagger.Equals(input.Stagger))
                ) && 
                (
                    this.StaggerAmount == input.StaggerAmount ||
                    (this.StaggerAmount != null &&
                    this.StaggerAmount.Equals(input.StaggerAmount))
                ) && 
                (
                    this.StaggerRestart == input.StaggerRestart ||
                    (this.StaggerRestart != null &&
                    this.StaggerRestart.Equals(input.StaggerRestart))
                ) && 
                (
                    this.HorizontalFill == input.HorizontalFill ||
                    (this.HorizontalFill != null &&
                    this.HorizontalFill.Equals(input.HorizontalFill))
                ) && 
                (
                    this.VerticalFill == input.VerticalFill ||
                    (this.VerticalFill != null &&
                    this.VerticalFill.Equals(input.VerticalFill))
                ) && 
                (
                    this.SheetMargins == input.SheetMargins ||
                    (this.SheetMargins != null &&
                    this.SheetMargins.Equals(input.SheetMargins))
                ) && 
                (
                    this.BleedOffset == input.BleedOffset ||
                    (this.BleedOffset != null &&
                    this.BleedOffset.Equals(input.BleedOffset))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Rows != null)
                    hashCode = hashCode * 59 + this.Rows.GetHashCode();
                if (this.Columns != null)
                    hashCode = hashCode * 59 + this.Columns.GetHashCode();
                if (this.HeadTurn != null)
                    hashCode = hashCode * 59 + this.HeadTurn.GetHashCode();
                if (this.InitialRotation != null)
                    hashCode = hashCode * 59 + this.InitialRotation.GetHashCode();
                if (this.HorizontalGapType != null)
                    hashCode = hashCode * 59 + this.HorizontalGapType.GetHashCode();
                if (this.VerticalGapType != null)
                    hashCode = hashCode * 59 + this.VerticalGapType.GetHashCode();
                if (this.HorizontalGap != null)
                    hashCode = hashCode * 59 + this.HorizontalGap.GetHashCode();
                if (this.VerticalGap != null)
                    hashCode = hashCode * 59 + this.VerticalGap.GetHashCode();
                if (this.EvenHorizontalGap != null)
                    hashCode = hashCode * 59 + this.EvenHorizontalGap.GetHashCode();
                if (this.EvenVerticalGap != null)
                    hashCode = hashCode * 59 + this.EvenVerticalGap.GetHashCode();
                if (this.Stagger != null)
                    hashCode = hashCode * 59 + this.Stagger.GetHashCode();
                if (this.StaggerAmount != null)
                    hashCode = hashCode * 59 + this.StaggerAmount.GetHashCode();
                if (this.StaggerRestart != null)
                    hashCode = hashCode * 59 + this.StaggerRestart.GetHashCode();
                if (this.HorizontalFill != null)
                    hashCode = hashCode * 59 + this.HorizontalFill.GetHashCode();
                if (this.VerticalFill != null)
                    hashCode = hashCode * 59 + this.VerticalFill.GetHashCode();
                if (this.SheetMargins != null)
                    hashCode = hashCode * 59 + this.SheetMargins.GetHashCode();
                if (this.BleedOffset != null)
                    hashCode = hashCode * 59 + this.BleedOffset.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
