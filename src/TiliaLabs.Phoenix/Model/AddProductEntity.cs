/* 
 * tilia Phoenix API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 7.0.6
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = TiliaLabs.Phoenix.Client.SwaggerDateConverter;

namespace TiliaLabs.Phoenix.Model
{
    /// <summary>
    /// Add product parameters
    /// </summary>
    [DataContract]
        public partial class AddProductEntity :  IEquatable<AddProductEntity>, IValidatableObject
    {
        /// <summary>
        /// Optional type of product: flat, tiled, bound, folded
        /// </summary>
        /// <value>Optional type of product: flat, tiled, bound, folded</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum TypeEnum
        {
            /// <summary>
            /// Enum Flat for value: Flat
            /// </summary>
            [EnumMember(Value = "Flat")]
            Flat = 1,
            /// <summary>
            /// Enum Tiled for value: Tiled
            /// </summary>
            [EnumMember(Value = "Tiled")]
            Tiled = 2,
            /// <summary>
            /// Enum Folded for value: Folded
            /// </summary>
            [EnumMember(Value = "Folded")]
            Folded = 3,
            /// <summary>
            /// Enum Bound for value: Bound
            /// </summary>
            [EnumMember(Value = "Bound")]
            Bound = 4        }
        /// <summary>
        /// Optional type of product: flat, tiled, bound, folded
        /// </summary>
        /// <value>Optional type of product: flat, tiled, bound, folded</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public TypeEnum? Type { get; set; }
        /// <summary>
        /// Setting to specify how toset up colors for each page
        /// </summary>
        /// <value>Setting to specify how toset up colors for each page</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum ColorSourceEnum
        {
            /// <summary>
            /// Enum Artwork for value: Artwork
            /// </summary>
            [EnumMember(Value = "Artwork")]
            Artwork = 1,
            /// <summary>
            /// Enum Specified for value: Specified
            /// </summary>
            [EnumMember(Value = "Specified")]
            Specified = 2        }
        /// <summary>
        /// Setting to specify how toset up colors for each page
        /// </summary>
        /// <value>Setting to specify how toset up colors for each page</value>
        [DataMember(Name="color-source", EmitDefaultValue=false)]
        public ColorSourceEnum? ColorSource { get; set; }
        /// <summary>
        /// Grain direction of product
        /// </summary>
        /// <value>Grain direction of product</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum GrainEnum
        {
            /// <summary>
            /// Enum Horizontal for value: Horizontal
            /// </summary>
            [EnumMember(Value = "Horizontal")]
            Horizontal = 1,
            /// <summary>
            /// Enum Vertical for value: Vertical
            /// </summary>
            [EnumMember(Value = "Vertical")]
            Vertical = 2,
            /// <summary>
            /// Enum Consistent for value: Consistent
            /// </summary>
            [EnumMember(Value = "Consistent")]
            Consistent = 3,
            /// <summary>
            /// Enum None for value: None
            /// </summary>
            [EnumMember(Value = "None")]
            None = 4        }
        /// <summary>
        /// Grain direction of product
        /// </summary>
        /// <value>Grain direction of product</value>
        [DataMember(Name="grain", EmitDefaultValue=false)]
        public GrainEnum? Grain { get; set; }
        /// <summary>
        /// Rotation type to allow in product, defaults to Product settings defaults unless allowed-rotations is defined in which case &#x27;Custom&#x27; rotation type is assumed
        /// </summary>
        /// <value>Rotation type to allow in product, defaults to Product settings defaults unless allowed-rotations is defined in which case &#x27;Custom&#x27; rotation type is assumed</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum RotationEnum
        {
            /// <summary>
            /// Enum Any for value: Any
            /// </summary>
            [EnumMember(Value = "Any")]
            Any = 1,
            /// <summary>
            /// Enum Orthogonal for value: Orthogonal
            /// </summary>
            [EnumMember(Value = "Orthogonal")]
            Orthogonal = 2,
            /// <summary>
            /// Enum None for value: None
            /// </summary>
            [EnumMember(Value = "None")]
            None = 3,
            /// <summary>
            /// Enum Custom for value: Custom
            /// </summary>
            [EnumMember(Value = "Custom")]
            Custom = 4        }
        /// <summary>
        /// Rotation type to allow in product, defaults to Product settings defaults unless allowed-rotations is defined in which case &#x27;Custom&#x27; rotation type is assumed
        /// </summary>
        /// <value>Rotation type to allow in product, defaults to Product settings defaults unless allowed-rotations is defined in which case &#x27;Custom&#x27; rotation type is assumed</value>
        [DataMember(Name="rotation", EmitDefaultValue=false)]
        public RotationEnum? Rotation { get; set; }
        /// <summary>
        /// Source type to use when creating dieshape for product.  If not defined, cad-file die takes priority, followed by dieshape library name, then height and width fields, and finally artwork Trimbox or artwork path line mappings depending on whether product settings automatically take dieshape from line mappings
        /// </summary>
        /// <value>Source type to use when creating dieshape for product.  If not defined, cad-file die takes priority, followed by dieshape library name, then height and width fields, and finally artwork Trimbox or artwork path line mappings depending on whether product settings automatically take dieshape from line mappings</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum DieshapeSourceEnum
        {
            /// <summary>
            /// Enum CAD for value: CAD
            /// </summary>
            [EnumMember(Value = "CAD")]
            CAD = 1,
            /// <summary>
            /// Enum ArtworkPaths for value: ArtworkPaths
            /// </summary>
            [EnumMember(Value = "ArtworkPaths")]
            ArtworkPaths = 2,
            /// <summary>
            /// Enum ArtworkTrimbox for value: ArtworkTrimbox
            /// </summary>
            [EnumMember(Value = "ArtworkTrimbox")]
            ArtworkTrimbox = 3,
            /// <summary>
            /// Enum CustomSize for value: CustomSize
            /// </summary>
            [EnumMember(Value = "CustomSize")]
            CustomSize = 4,
            /// <summary>
            /// Enum DieDesignLibrary for value: DieDesignLibrary
            /// </summary>
            [EnumMember(Value = "DieDesignLibrary")]
            DieDesignLibrary = 5        }
        /// <summary>
        /// Source type to use when creating dieshape for product.  If not defined, cad-file die takes priority, followed by dieshape library name, then height and width fields, and finally artwork Trimbox or artwork path line mappings depending on whether product settings automatically take dieshape from line mappings
        /// </summary>
        /// <value>Source type to use when creating dieshape for product.  If not defined, cad-file die takes priority, followed by dieshape library name, then height and width fields, and finally artwork Trimbox or artwork path line mappings depending on whether product settings automatically take dieshape from line mappings</value>
        [DataMember(Name="dieshape-source", EmitDefaultValue=false)]
        public DieshapeSourceEnum? DieshapeSource { get; set; }
        /// <summary>
        /// Shape handling mode to use when finding closed path shapes from the dielines in the artwork.  &#x27;Multiple&#x27; mode will create a new product for each closed path shape detected in the artwork.
        /// </summary>
        /// <value>Shape handling mode to use when finding closed path shapes from the dielines in the artwork.  &#x27;Multiple&#x27; mode will create a new product for each closed path shape detected in the artwork.</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum ShapeHandlingEnum
        {
            /// <summary>
            /// Enum Largest for value: Largest
            /// </summary>
            [EnumMember(Value = "Largest")]
            Largest = 1,
            /// <summary>
            /// Enum Multiple for value: Multiple
            /// </summary>
            [EnumMember(Value = "Multiple")]
            Multiple = 2        }
        /// <summary>
        /// Shape handling mode to use when finding closed path shapes from the dielines in the artwork.  &#x27;Multiple&#x27; mode will create a new product for each closed path shape detected in the artwork.
        /// </summary>
        /// <value>Shape handling mode to use when finding closed path shapes from the dielines in the artwork.  &#x27;Multiple&#x27; mode will create a new product for each closed path shape detected in the artwork.</value>
        [DataMember(Name="shape-handling", EmitDefaultValue=false)]
        public ShapeHandlingEnum? ShapeHandling { get; set; }
        /// <summary>
        /// Multi-page artwork handling options for flat and tiled products
        /// </summary>
        /// <value>Multi-page artwork handling options for flat and tiled products</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum PageHandlingEnum
        {
            /// <summary>
            /// Enum OnePerFile for value: OnePerFile
            /// </summary>
            [EnumMember(Value = "OnePerFile")]
            OnePerFile = 1,
            /// <summary>
            /// Enum OnePerPage for value: OnePerPage
            /// </summary>
            [EnumMember(Value = "OnePerPage")]
            OnePerPage = 2,
            /// <summary>
            /// Enum OnePerTwoPages for value: OnePerTwoPages
            /// </summary>
            [EnumMember(Value = "OnePerTwoPages")]
            OnePerTwoPages = 3        }
        /// <summary>
        /// Multi-page artwork handling options for flat and tiled products
        /// </summary>
        /// <value>Multi-page artwork handling options for flat and tiled products</value>
        [DataMember(Name="page-handling", EmitDefaultValue=false)]
        public PageHandlingEnum? PageHandling { get; set; }
        /// <summary>
        /// Action to perform to copy or mirror artwork on the front side of the flat product to the back side
        /// </summary>
        /// <value>Action to perform to copy or mirror artwork on the front side of the flat product to the back side</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum FrontToBackEnum
        {
            /// <summary>
            /// Enum None for value: None
            /// </summary>
            [EnumMember(Value = "None")]
            None = 1,
            /// <summary>
            /// Enum Copy for value: Copy
            /// </summary>
            [EnumMember(Value = "Copy")]
            Copy = 2,
            /// <summary>
            /// Enum Mirror for value: Mirror
            /// </summary>
            [EnumMember(Value = "Mirror")]
            Mirror = 3        }
        /// <summary>
        /// Action to perform to copy or mirror artwork on the front side of the flat product to the back side
        /// </summary>
        /// <value>Action to perform to copy or mirror artwork on the front side of the flat product to the back side</value>
        [DataMember(Name="front-to-back", EmitDefaultValue=false)]
        public FrontToBackEnum? FrontToBack { get; set; }
        /// <summary>
        /// Product bleed type &#x3D; [Margins, Contour, Cad, or None]
        /// </summary>
        /// <value>Product bleed type &#x3D; [Margins, Contour, Cad, or None]</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum BleedTypeEnum
        {
            /// <summary>
            /// Enum Margins for value: Margins
            /// </summary>
            [EnumMember(Value = "Margins")]
            Margins = 1,
            /// <summary>
            /// Enum Contour for value: Contour
            /// </summary>
            [EnumMember(Value = "Contour")]
            Contour = 2,
            /// <summary>
            /// Enum CAD for value: CAD
            /// </summary>
            [EnumMember(Value = "CAD")]
            CAD = 3,
            /// <summary>
            /// Enum None for value: None
            /// </summary>
            [EnumMember(Value = "None")]
            None = 4        }
        /// <summary>
        /// Product bleed type &#x3D; [Margins, Contour, Cad, or None]
        /// </summary>
        /// <value>Product bleed type &#x3D; [Margins, Contour, Cad, or None]</value>
        [DataMember(Name="bleed-type", EmitDefaultValue=false)]
        public BleedTypeEnum? BleedType { get; set; }
        /// <summary>
        /// Product spacing type &#x3D; [Margins, Uniform, or Bleed]
        /// </summary>
        /// <value>Product spacing type &#x3D; [Margins, Uniform, or Bleed]</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum SpacingTypeEnum
        {
            /// <summary>
            /// Enum Margins for value: Margins
            /// </summary>
            [EnumMember(Value = "Margins")]
            Margins = 1,
            /// <summary>
            /// Enum Uniform for value: Uniform
            /// </summary>
            [EnumMember(Value = "Uniform")]
            Uniform = 2,
            /// <summary>
            /// Enum Bleed for value: Bleed
            /// </summary>
            [EnumMember(Value = "Bleed")]
            Bleed = 3,
            /// <summary>
            /// Enum Tool for value: Tool
            /// </summary>
            [EnumMember(Value = "Tool")]
            Tool = 4        }
        /// <summary>
        /// Product spacing type &#x3D; [Margins, Uniform, or Bleed]
        /// </summary>
        /// <value>Product spacing type &#x3D; [Margins, Uniform, or Bleed]</value>
        [DataMember(Name="spacing-type", EmitDefaultValue=false)]
        public SpacingTypeEnum? SpacingType { get; set; }
        /// <summary>
        /// Optional binding method for bound work 
        /// </summary>
        /// <value>Optional binding method for bound work </value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum BindingMethodEnum
        {
            /// <summary>
            /// Enum PerfectBound for value: PerfectBound
            /// </summary>
            [EnumMember(Value = "PerfectBound")]
            PerfectBound = 1,
            /// <summary>
            /// Enum SaddleStitch for value: SaddleStitch
            /// </summary>
            [EnumMember(Value = "SaddleStitch")]
            SaddleStitch = 2,
            /// <summary>
            /// Enum None for value: None
            /// </summary>
            [EnumMember(Value = "None")]
            None = 3        }
        /// <summary>
        /// Optional binding method for bound work 
        /// </summary>
        /// <value>Optional binding method for bound work </value>
        [DataMember(Name="binding-method", EmitDefaultValue=false)]
        public BindingMethodEnum? BindingMethod { get; set; }
        /// <summary>
        /// Page binding edge for bound work
        /// </summary>
        /// <value>Page binding edge for bound work</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum BindingEdgeEnum
        {
            /// <summary>
            /// Enum Top for value: Top
            /// </summary>
            [EnumMember(Value = "Top")]
            Top = 1,
            /// <summary>
            /// Enum Bottom for value: Bottom
            /// </summary>
            [EnumMember(Value = "Bottom")]
            Bottom = 2,
            /// <summary>
            /// Enum Right for value: Right
            /// </summary>
            [EnumMember(Value = "Right")]
            Right = 3,
            /// <summary>
            /// Enum Left for value: Left
            /// </summary>
            [EnumMember(Value = "Left")]
            Left = 4        }
        /// <summary>
        /// Page binding edge for bound work
        /// </summary>
        /// <value>Page binding edge for bound work</value>
        [DataMember(Name="binding-edge", EmitDefaultValue=false)]
        public BindingEdgeEnum? BindingEdge { get; set; }
        /// <summary>
        /// Jog edge for bound work.  When set, this edge must be perpendicular to the binding edge.  Setting jog to Bottom for left- or right-bound work results in &#x27;Foot to Foot&#x27; page orientation.
        /// </summary>
        /// <value>Jog edge for bound work.  When set, this edge must be perpendicular to the binding edge.  Setting jog to Bottom for left- or right-bound work results in &#x27;Foot to Foot&#x27; page orientation.</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum JogEdgeEnum
        {
            /// <summary>
            /// Enum Top for value: Top
            /// </summary>
            [EnumMember(Value = "Top")]
            Top = 1,
            /// <summary>
            /// Enum Bottom for value: Bottom
            /// </summary>
            [EnumMember(Value = "Bottom")]
            Bottom = 2,
            /// <summary>
            /// Enum Right for value: Right
            /// </summary>
            [EnumMember(Value = "Right")]
            Right = 3,
            /// <summary>
            /// Enum Left for value: Left
            /// </summary>
            [EnumMember(Value = "Left")]
            Left = 4        }
        /// <summary>
        /// Jog edge for bound work.  When set, this edge must be perpendicular to the binding edge.  Setting jog to Bottom for left- or right-bound work results in &#x27;Foot to Foot&#x27; page orientation.
        /// </summary>
        /// <value>Jog edge for bound work.  When set, this edge must be perpendicular to the binding edge.  Setting jog to Bottom for left- or right-bound work results in &#x27;Foot to Foot&#x27; page orientation.</value>
        [DataMember(Name="jog-edge", EmitDefaultValue=false)]
        public JogEdgeEnum? JogEdge { get; set; }
        /// <summary>
        /// Reading order of pages in bound work
        /// </summary>
        /// <value>Reading order of pages in bound work</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum ReadingOrderEnum
        {
            /// <summary>
            /// Enum Normal for value: Normal
            /// </summary>
            [EnumMember(Value = "Normal")]
            Normal = 1,
            /// <summary>
            /// Enum Calendar for value: Calendar
            /// </summary>
            [EnumMember(Value = "Calendar")]
            Calendar = 2        }
        /// <summary>
        /// Reading order of pages in bound work
        /// </summary>
        /// <value>Reading order of pages in bound work</value>
        [DataMember(Name="reading-order", EmitDefaultValue=false)]
        public ReadingOrderEnum? ReadingOrder { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="AddProductEntity" /> class.
        /// </summary>
        /// <param name="name">Unique name of the product.</param>
        /// <param name="type">Optional type of product: flat, tiled, bound, folded.</param>
        /// <param name="color">Product color specified as RGB or ARGB hex value with optional leading hex (&#x27;#&#x27;) symbol.</param>
        /// <param name="ordered">Number of product ordered in the job.</param>
        /// <param name="stock">Stock of product.</param>
        /// <param name="grade">Grade of product stock.</param>
        /// <param name="colors">Page colors for front side of flat products or all pages of bound and folded products.</param>
        /// <param name="backColors">Page back colors for back side of flat products.</param>
        /// <param name="colorSource">Setting to specify how toset up colors for each page.</param>
        /// <param name="grain">Grain direction of product.</param>
        /// <param name="width">Width of product when creating a custom size product or the desired scaled width or scale percentage when creating the product die from a die design or artwork.</param>
        /// <param name="height">Height of product when creating a custom size product or the desired scaled height or scale percentage when creating the product die from a die design or artwork.</param>
        /// <param name="rotation">Rotation type to allow in product, defaults to Product settings defaults unless allowed-rotations is defined in which case &#x27;Custom&#x27; rotation type is assumed.</param>
        /// <param name="allowedRotations">Allowed rotations of product when rotation type is &#x27;Custom&#x27;.</param>
        /// <param name="templates">List of templates this product can be used with.</param>
        /// <param name="scaleProportionally">Whether to scale proportionally when either width or height are not specified.  When false, only the dimension that is specified is scaled.  Defaults to false..</param>
        /// <param name="artwork">Path to artwork file when creating product from artwork or snapping artwork into die.</param>
        /// <param name="page">Page of artwork to use, defaults to page 1 when not defined.</param>
        /// <param name="backArtwork">Path to artwork file for back side of product when creating product from artwork or snapping artwork into die.</param>
        /// <param name="backPage">Page of artwork to use for back side of product.</param>
        /// <param name="dieshapeSource">Source type to use when creating dieshape for product.  If not defined, cad-file die takes priority, followed by dieshape library name, then height and width fields, and finally artwork Trimbox or artwork path line mappings depending on whether product settings automatically take dieshape from line mappings.</param>
        /// <param name="dieDesign">Path to die in Die Design Library when using library die design for 1-up die of the product.</param>
        /// <param name="autosnapInk">PDF ink color to use for autosnapping artwork into 1-up die on the front side of the product.</param>
        /// <param name="backAutosnapInk">PDF ink color to use for autosnapping artwork into 1-up die on the back side of the product.</param>
        /// <param name="autosnapLayer">PDF layer to use for autosnapping artwork into 1-up die on the front side of the product.</param>
        /// <param name="backAutosnapLayer">PDF layer to use for autosnapping artwork into 1-up die on the back side of the product.</param>
        /// <param name="shapeHandling">Shape handling mode to use when finding closed path shapes from the dielines in the artwork.  &#x27;Multiple&#x27; mode will create a new product for each closed path shape detected in the artwork..</param>
        /// <param name="pageHandling">Multi-page artwork handling options for flat and tiled products.</param>
        /// <param name="frontToBack">Action to perform to copy or mirror artwork on the front side of the flat product to the back side.</param>
        /// <param name="cadFile">Path of CAD file to use when defining product based on 1-up design in a CAD file.</param>
        /// <param name="cadDesign">Design name of 1-up CAD design in the CAD file, defaults to first 1-up in the CAD file when not defined.</param>
        /// <param name="group">Optional product group used in Imposition AI.</param>
        /// <param name="priority">Optional priority of product starting from 1 as highest priority.</param>
        /// <param name="dueDate">Product due date.</param>
        /// <param name="bleedType">Product bleed type &#x3D; [Margins, Contour, Cad, or None].</param>
        /// <param name="bleedMargin">Scalar offset from die design to generate bleed.</param>
        /// <param name="bleedMargins">bleedMargins.</param>
        /// <param name="pageBleed">Bleed margins of individual pages in bound and folded products.</param>
        /// <param name="spacingType">Product spacing type &#x3D; [Margins, Uniform, or Bleed].</param>
        /// <param name="spacingMargin">Single scalar spacing offset when spacing type is Uniform.</param>
        /// <param name="spacingMargins">spacingMargins.</param>
        /// <param name="offcutMargins">offcutMargins.</param>
        /// <param name="minOverruns">Minimum overrun percentage allowed for the product.</param>
        /// <param name="maxOverruns">Maximum overrun percentage allowed for the product.</param>
        /// <param name="description">Optional product description.</param>
        /// <param name="notes">Optional notes to associate with product.</param>
        /// <param name="processSettings">List of process settings to use to control process-specific behavior.</param>
        /// <param name="marks">Optional product marks to apply to the front side of the product.</param>
        /// <param name="backMarks">Optional product marks to apply to the back side of the product.</param>
        /// <param name="foldingPatterns">Optional folding bound work.</param>
        /// <param name="bindingMethod">Optional binding method for bound work .</param>
        /// <param name="bindingEdge">Page binding edge for bound work.</param>
        /// <param name="jogEdge">Jog edge for bound work.  When set, this edge must be perpendicular to the binding edge.  Setting jog to Bottom for left- or right-bound work results in &#x27;Foot to Foot&#x27; page orientation..</param>
        /// <param name="readingOrder">Reading order of pages in bound work.</param>
        /// <param name="pages">Total number of pages field for bound and folded work.</param>
        /// <param name="pagesPerSection">Number of pages per section for multi-section bound work.</param>
        /// <param name="selfCover">Whether bound part includes cover or not.</param>
        /// <param name="trim">trim.</param>
        /// <param name="nUp">nUp.</param>
        /// <param name="creep">creep.</param>
        /// <param name="bundleSize">Bundle size needed for product.  When set, Imposition AI tools will ensure layouts including this product will have run length multiples of this bundle size.</param>
        /// <param name="properties">Optional custom properties to apply to the product.</param>
        /// <param name="tiling">tiling.</param>
        /// <param name="frontInks">(Deprecated) Printing inks on front side of product.</param>
        /// <param name="backInks">(Deprecated) Printing inks on back side of product.</param>
        /// <param name="cutInk">(Deprecated) Spot ink color used to define cut lines in the artwork.</param>
        /// <param name="creaseInk">(Deprecated) Spot ink color used to define crease lines in the artwork.</param>
        /// <param name="bleedInk">(Deprecated) Spot ink color used to define bleed lines in the artwork.</param>
        /// <param name="cutLayer">(Deprecated) PDF layer name used to define cut lines in the artwork.</param>
        /// <param name="creaseLayer">(Deprecated) PDF layer name used to define crease lines in the artwork.</param>
        /// <param name="bleedLayer">(Deprecated) PDF layer name used to define bleed lines in the artwork.</param>
        public AddProductEntity(string name = default(string), TypeEnum? type = default(TypeEnum?), string color = default(string), int? ordered = default(int?), string stock = default(string), string grade = default(string), List<PageColorEntity> colors = default(List<PageColorEntity>), List<PageColorEntity> backColors = default(List<PageColorEntity>), ColorSourceEnum? colorSource = default(ColorSourceEnum?), GrainEnum? grain = default(GrainEnum?), string width = default(string), string height = default(string), RotationEnum? rotation = default(RotationEnum?), string allowedRotations = default(string), List<string> templates = default(List<string>), bool? scaleProportionally = default(bool?), string artwork = default(string), int? page = default(int?), string backArtwork = default(string), int? backPage = default(int?), DieshapeSourceEnum? dieshapeSource = default(DieshapeSourceEnum?), string dieDesign = default(string), string autosnapInk = default(string), string backAutosnapInk = default(string), string autosnapLayer = default(string), string backAutosnapLayer = default(string), ShapeHandlingEnum? shapeHandling = default(ShapeHandlingEnum?), PageHandlingEnum? pageHandling = default(PageHandlingEnum?), FrontToBackEnum? frontToBack = default(FrontToBackEnum?), string cadFile = default(string), string cadDesign = default(string), string group = default(string), int? priority = default(int?), string dueDate = default(string), BleedTypeEnum? bleedType = default(BleedTypeEnum?), string bleedMargin = default(string), MarginsEntity bleedMargins = default(MarginsEntity), string pageBleed = default(string), SpacingTypeEnum? spacingType = default(SpacingTypeEnum?), string spacingMargin = default(string), MarginsEntity spacingMargins = default(MarginsEntity), MarginsEntity offcutMargins = default(MarginsEntity), string minOverruns = default(string), string maxOverruns = default(string), string description = default(string), string notes = default(string), List<ProcessSettingEntity> processSettings = default(List<ProcessSettingEntity>), List<string> marks = default(List<string>), List<string> backMarks = default(List<string>), List<string> foldingPatterns = default(List<string>), BindingMethodEnum? bindingMethod = default(BindingMethodEnum?), BindingEdgeEnum? bindingEdge = default(BindingEdgeEnum?), JogEdgeEnum? jogEdge = default(JogEdgeEnum?), ReadingOrderEnum? readingOrder = default(ReadingOrderEnum?), int? pages = default(int?), int? pagesPerSection = default(int?), bool? selfCover = default(bool?), TrimEntity trim = default(TrimEntity), NUpEntity nUp = default(NUpEntity), CreepEntity creep = default(CreepEntity), int? bundleSize = default(int?), List<PropertyEntity> properties = default(List<PropertyEntity>), Tiling tiling = default(Tiling), List<string> frontInks = default(List<string>), List<string> backInks = default(List<string>), string cutInk = default(string), string creaseInk = default(string), string bleedInk = default(string), string cutLayer = default(string), string creaseLayer = default(string), string bleedLayer = default(string))
        {
            this.Name = name;
            this.Type = type;
            this.Color = color;
            this.Ordered = ordered;
            this.Stock = stock;
            this.Grade = grade;
            this.Colors = colors;
            this.BackColors = backColors;
            this.ColorSource = colorSource;
            this.Grain = grain;
            this.Width = width;
            this.Height = height;
            this.Rotation = rotation;
            this.AllowedRotations = allowedRotations;
            this.Templates = templates;
            this.ScaleProportionally = scaleProportionally;
            this.Artwork = artwork;
            this.Page = page;
            this.BackArtwork = backArtwork;
            this.BackPage = backPage;
            this.DieshapeSource = dieshapeSource;
            this.DieDesign = dieDesign;
            this.AutosnapInk = autosnapInk;
            this.BackAutosnapInk = backAutosnapInk;
            this.AutosnapLayer = autosnapLayer;
            this.BackAutosnapLayer = backAutosnapLayer;
            this.ShapeHandling = shapeHandling;
            this.PageHandling = pageHandling;
            this.FrontToBack = frontToBack;
            this.CadFile = cadFile;
            this.CadDesign = cadDesign;
            this.Group = group;
            this.Priority = priority;
            this.DueDate = dueDate;
            this.BleedType = bleedType;
            this.BleedMargin = bleedMargin;
            this.BleedMargins = bleedMargins;
            this.PageBleed = pageBleed;
            this.SpacingType = spacingType;
            this.SpacingMargin = spacingMargin;
            this.SpacingMargins = spacingMargins;
            this.OffcutMargins = offcutMargins;
            this.MinOverruns = minOverruns;
            this.MaxOverruns = maxOverruns;
            this.Description = description;
            this.Notes = notes;
            this.ProcessSettings = processSettings;
            this.Marks = marks;
            this.BackMarks = backMarks;
            this.FoldingPatterns = foldingPatterns;
            this.BindingMethod = bindingMethod;
            this.BindingEdge = bindingEdge;
            this.JogEdge = jogEdge;
            this.ReadingOrder = readingOrder;
            this.Pages = pages;
            this.PagesPerSection = pagesPerSection;
            this.SelfCover = selfCover;
            this.Trim = trim;
            this.NUp = nUp;
            this.Creep = creep;
            this.BundleSize = bundleSize;
            this.Properties = properties;
            this.Tiling = tiling;
            this.FrontInks = frontInks;
            this.BackInks = backInks;
            this.CutInk = cutInk;
            this.CreaseInk = creaseInk;
            this.BleedInk = bleedInk;
            this.CutLayer = cutLayer;
            this.CreaseLayer = creaseLayer;
            this.BleedLayer = bleedLayer;
        }
        
        /// <summary>
        /// Unique name of the product
        /// </summary>
        /// <value>Unique name of the product</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }


        /// <summary>
        /// Product color specified as RGB or ARGB hex value with optional leading hex (&#x27;#&#x27;) symbol
        /// </summary>
        /// <value>Product color specified as RGB or ARGB hex value with optional leading hex (&#x27;#&#x27;) symbol</value>
        [DataMember(Name="color", EmitDefaultValue=false)]
        public string Color { get; set; }

        /// <summary>
        /// Number of product ordered in the job
        /// </summary>
        /// <value>Number of product ordered in the job</value>
        [DataMember(Name="ordered", EmitDefaultValue=false)]
        public int? Ordered { get; set; }

        /// <summary>
        /// Stock of product
        /// </summary>
        /// <value>Stock of product</value>
        [DataMember(Name="stock", EmitDefaultValue=false)]
        public string Stock { get; set; }

        /// <summary>
        /// Grade of product stock
        /// </summary>
        /// <value>Grade of product stock</value>
        [DataMember(Name="grade", EmitDefaultValue=false)]
        public string Grade { get; set; }

        /// <summary>
        /// Page colors for front side of flat products or all pages of bound and folded products
        /// </summary>
        /// <value>Page colors for front side of flat products or all pages of bound and folded products</value>
        [DataMember(Name="colors", EmitDefaultValue=false)]
        public List<PageColorEntity> Colors { get; set; }

        /// <summary>
        /// Page back colors for back side of flat products
        /// </summary>
        /// <value>Page back colors for back side of flat products</value>
        [DataMember(Name="back-colors", EmitDefaultValue=false)]
        public List<PageColorEntity> BackColors { get; set; }



        /// <summary>
        /// Width of product when creating a custom size product or the desired scaled width or scale percentage when creating the product die from a die design or artwork
        /// </summary>
        /// <value>Width of product when creating a custom size product or the desired scaled width or scale percentage when creating the product die from a die design or artwork</value>
        [DataMember(Name="width", EmitDefaultValue=false)]
        public string Width { get; set; }

        /// <summary>
        /// Height of product when creating a custom size product or the desired scaled height or scale percentage when creating the product die from a die design or artwork
        /// </summary>
        /// <value>Height of product when creating a custom size product or the desired scaled height or scale percentage when creating the product die from a die design or artwork</value>
        [DataMember(Name="height", EmitDefaultValue=false)]
        public string Height { get; set; }


        /// <summary>
        /// Allowed rotations of product when rotation type is &#x27;Custom&#x27;
        /// </summary>
        /// <value>Allowed rotations of product when rotation type is &#x27;Custom&#x27;</value>
        [DataMember(Name="allowed-rotations", EmitDefaultValue=false)]
        public string AllowedRotations { get; set; }

        /// <summary>
        /// List of templates this product can be used with
        /// </summary>
        /// <value>List of templates this product can be used with</value>
        [DataMember(Name="templates", EmitDefaultValue=false)]
        public List<string> Templates { get; set; }

        /// <summary>
        /// Whether to scale proportionally when either width or height are not specified.  When false, only the dimension that is specified is scaled.  Defaults to false.
        /// </summary>
        /// <value>Whether to scale proportionally when either width or height are not specified.  When false, only the dimension that is specified is scaled.  Defaults to false.</value>
        [DataMember(Name="scale-proportionally", EmitDefaultValue=false)]
        public bool? ScaleProportionally { get; set; }

        /// <summary>
        /// Path to artwork file when creating product from artwork or snapping artwork into die
        /// </summary>
        /// <value>Path to artwork file when creating product from artwork or snapping artwork into die</value>
        [DataMember(Name="artwork", EmitDefaultValue=false)]
        public string Artwork { get; set; }

        /// <summary>
        /// Page of artwork to use, defaults to page 1 when not defined
        /// </summary>
        /// <value>Page of artwork to use, defaults to page 1 when not defined</value>
        [DataMember(Name="page", EmitDefaultValue=false)]
        public int? Page { get; set; }

        /// <summary>
        /// Path to artwork file for back side of product when creating product from artwork or snapping artwork into die
        /// </summary>
        /// <value>Path to artwork file for back side of product when creating product from artwork or snapping artwork into die</value>
        [DataMember(Name="back-artwork", EmitDefaultValue=false)]
        public string BackArtwork { get; set; }

        /// <summary>
        /// Page of artwork to use for back side of product
        /// </summary>
        /// <value>Page of artwork to use for back side of product</value>
        [DataMember(Name="back-page", EmitDefaultValue=false)]
        public int? BackPage { get; set; }


        /// <summary>
        /// Path to die in Die Design Library when using library die design for 1-up die of the product
        /// </summary>
        /// <value>Path to die in Die Design Library when using library die design for 1-up die of the product</value>
        [DataMember(Name="die-design", EmitDefaultValue=false)]
        public string DieDesign { get; set; }

        /// <summary>
        /// PDF ink color to use for autosnapping artwork into 1-up die on the front side of the product
        /// </summary>
        /// <value>PDF ink color to use for autosnapping artwork into 1-up die on the front side of the product</value>
        [DataMember(Name="autosnap-ink", EmitDefaultValue=false)]
        public string AutosnapInk { get; set; }

        /// <summary>
        /// PDF ink color to use for autosnapping artwork into 1-up die on the back side of the product
        /// </summary>
        /// <value>PDF ink color to use for autosnapping artwork into 1-up die on the back side of the product</value>
        [DataMember(Name="back-autosnap-ink", EmitDefaultValue=false)]
        public string BackAutosnapInk { get; set; }

        /// <summary>
        /// PDF layer to use for autosnapping artwork into 1-up die on the front side of the product
        /// </summary>
        /// <value>PDF layer to use for autosnapping artwork into 1-up die on the front side of the product</value>
        [DataMember(Name="autosnap-layer", EmitDefaultValue=false)]
        public string AutosnapLayer { get; set; }

        /// <summary>
        /// PDF layer to use for autosnapping artwork into 1-up die on the back side of the product
        /// </summary>
        /// <value>PDF layer to use for autosnapping artwork into 1-up die on the back side of the product</value>
        [DataMember(Name="back-autosnap-layer", EmitDefaultValue=false)]
        public string BackAutosnapLayer { get; set; }




        /// <summary>
        /// Path of CAD file to use when defining product based on 1-up design in a CAD file
        /// </summary>
        /// <value>Path of CAD file to use when defining product based on 1-up design in a CAD file</value>
        [DataMember(Name="cad-file", EmitDefaultValue=false)]
        public string CadFile { get; set; }

        /// <summary>
        /// Design name of 1-up CAD design in the CAD file, defaults to first 1-up in the CAD file when not defined
        /// </summary>
        /// <value>Design name of 1-up CAD design in the CAD file, defaults to first 1-up in the CAD file when not defined</value>
        [DataMember(Name="cad-design", EmitDefaultValue=false)]
        public string CadDesign { get; set; }

        /// <summary>
        /// Optional product group used in Imposition AI
        /// </summary>
        /// <value>Optional product group used in Imposition AI</value>
        [DataMember(Name="group", EmitDefaultValue=false)]
        public string Group { get; set; }

        /// <summary>
        /// Optional priority of product starting from 1 as highest priority
        /// </summary>
        /// <value>Optional priority of product starting from 1 as highest priority</value>
        [DataMember(Name="priority", EmitDefaultValue=false)]
        public int? Priority { get; set; }

        /// <summary>
        /// Product due date
        /// </summary>
        /// <value>Product due date</value>
        [DataMember(Name="due-date", EmitDefaultValue=false)]
        public string DueDate { get; set; }


        /// <summary>
        /// Scalar offset from die design to generate bleed
        /// </summary>
        /// <value>Scalar offset from die design to generate bleed</value>
        [DataMember(Name="bleed-margin", EmitDefaultValue=false)]
        public string BleedMargin { get; set; }

        /// <summary>
        /// Gets or Sets BleedMargins
        /// </summary>
        [DataMember(Name="bleed-margins", EmitDefaultValue=false)]
        public MarginsEntity BleedMargins { get; set; }

        /// <summary>
        /// Bleed margins of individual pages in bound and folded products
        /// </summary>
        /// <value>Bleed margins of individual pages in bound and folded products</value>
        [DataMember(Name="page-bleed", EmitDefaultValue=false)]
        public string PageBleed { get; set; }


        /// <summary>
        /// Single scalar spacing offset when spacing type is Uniform
        /// </summary>
        /// <value>Single scalar spacing offset when spacing type is Uniform</value>
        [DataMember(Name="spacing-margin", EmitDefaultValue=false)]
        public string SpacingMargin { get; set; }

        /// <summary>
        /// Gets or Sets SpacingMargins
        /// </summary>
        [DataMember(Name="spacing-margins", EmitDefaultValue=false)]
        public MarginsEntity SpacingMargins { get; set; }

        /// <summary>
        /// Gets or Sets OffcutMargins
        /// </summary>
        [DataMember(Name="offcut-margins", EmitDefaultValue=false)]
        public MarginsEntity OffcutMargins { get; set; }

        /// <summary>
        /// Minimum overrun percentage allowed for the product
        /// </summary>
        /// <value>Minimum overrun percentage allowed for the product</value>
        [DataMember(Name="min-overruns", EmitDefaultValue=false)]
        public string MinOverruns { get; set; }

        /// <summary>
        /// Maximum overrun percentage allowed for the product
        /// </summary>
        /// <value>Maximum overrun percentage allowed for the product</value>
        [DataMember(Name="max-overruns", EmitDefaultValue=false)]
        public string MaxOverruns { get; set; }

        /// <summary>
        /// Optional product description
        /// </summary>
        /// <value>Optional product description</value>
        [DataMember(Name="description", EmitDefaultValue=false)]
        public string Description { get; set; }

        /// <summary>
        /// Optional notes to associate with product
        /// </summary>
        /// <value>Optional notes to associate with product</value>
        [DataMember(Name="notes", EmitDefaultValue=false)]
        public string Notes { get; set; }

        /// <summary>
        /// List of process settings to use to control process-specific behavior
        /// </summary>
        /// <value>List of process settings to use to control process-specific behavior</value>
        [DataMember(Name="process-settings", EmitDefaultValue=false)]
        public List<ProcessSettingEntity> ProcessSettings { get; set; }

        /// <summary>
        /// Optional product marks to apply to the front side of the product
        /// </summary>
        /// <value>Optional product marks to apply to the front side of the product</value>
        [DataMember(Name="marks", EmitDefaultValue=false)]
        public List<string> Marks { get; set; }

        /// <summary>
        /// Optional product marks to apply to the back side of the product
        /// </summary>
        /// <value>Optional product marks to apply to the back side of the product</value>
        [DataMember(Name="back-marks", EmitDefaultValue=false)]
        public List<string> BackMarks { get; set; }

        /// <summary>
        /// Optional folding bound work
        /// </summary>
        /// <value>Optional folding bound work</value>
        [DataMember(Name="folding-patterns", EmitDefaultValue=false)]
        public List<string> FoldingPatterns { get; set; }





        /// <summary>
        /// Total number of pages field for bound and folded work
        /// </summary>
        /// <value>Total number of pages field for bound and folded work</value>
        [DataMember(Name="pages", EmitDefaultValue=false)]
        public int? Pages { get; set; }

        /// <summary>
        /// Number of pages per section for multi-section bound work
        /// </summary>
        /// <value>Number of pages per section for multi-section bound work</value>
        [DataMember(Name="pages-per-section", EmitDefaultValue=false)]
        public int? PagesPerSection { get; set; }

        /// <summary>
        /// Whether bound part includes cover or not
        /// </summary>
        /// <value>Whether bound part includes cover or not</value>
        [DataMember(Name="self-cover", EmitDefaultValue=false)]
        public bool? SelfCover { get; set; }

        /// <summary>
        /// Gets or Sets Trim
        /// </summary>
        [DataMember(Name="trim", EmitDefaultValue=false)]
        public TrimEntity Trim { get; set; }

        /// <summary>
        /// Gets or Sets NUp
        /// </summary>
        [DataMember(Name="n-up", EmitDefaultValue=false)]
        public NUpEntity NUp { get; set; }

        /// <summary>
        /// Gets or Sets Creep
        /// </summary>
        [DataMember(Name="creep", EmitDefaultValue=false)]
        public CreepEntity Creep { get; set; }

        /// <summary>
        /// Bundle size needed for product.  When set, Imposition AI tools will ensure layouts including this product will have run length multiples of this bundle size
        /// </summary>
        /// <value>Bundle size needed for product.  When set, Imposition AI tools will ensure layouts including this product will have run length multiples of this bundle size</value>
        [DataMember(Name="bundle-size", EmitDefaultValue=false)]
        public int? BundleSize { get; set; }

        /// <summary>
        /// Optional custom properties to apply to the product
        /// </summary>
        /// <value>Optional custom properties to apply to the product</value>
        [DataMember(Name="properties", EmitDefaultValue=false)]
        public List<PropertyEntity> Properties { get; set; }

        /// <summary>
        /// Gets or Sets Tiling
        /// </summary>
        [DataMember(Name="tiling", EmitDefaultValue=false)]
        public Tiling Tiling { get; set; }

        /// <summary>
        /// (Deprecated) Printing inks on front side of product
        /// </summary>
        /// <value>(Deprecated) Printing inks on front side of product</value>
        [DataMember(Name="front-inks", EmitDefaultValue=false)]
        public List<string> FrontInks { get; set; }

        /// <summary>
        /// (Deprecated) Printing inks on back side of product
        /// </summary>
        /// <value>(Deprecated) Printing inks on back side of product</value>
        [DataMember(Name="back-inks", EmitDefaultValue=false)]
        public List<string> BackInks { get; set; }

        /// <summary>
        /// (Deprecated) Spot ink color used to define cut lines in the artwork
        /// </summary>
        /// <value>(Deprecated) Spot ink color used to define cut lines in the artwork</value>
        [DataMember(Name="cut-ink", EmitDefaultValue=false)]
        public string CutInk { get; set; }

        /// <summary>
        /// (Deprecated) Spot ink color used to define crease lines in the artwork
        /// </summary>
        /// <value>(Deprecated) Spot ink color used to define crease lines in the artwork</value>
        [DataMember(Name="crease-ink", EmitDefaultValue=false)]
        public string CreaseInk { get; set; }

        /// <summary>
        /// (Deprecated) Spot ink color used to define bleed lines in the artwork
        /// </summary>
        /// <value>(Deprecated) Spot ink color used to define bleed lines in the artwork</value>
        [DataMember(Name="bleed-ink", EmitDefaultValue=false)]
        public string BleedInk { get; set; }

        /// <summary>
        /// (Deprecated) PDF layer name used to define cut lines in the artwork
        /// </summary>
        /// <value>(Deprecated) PDF layer name used to define cut lines in the artwork</value>
        [DataMember(Name="cut-layer", EmitDefaultValue=false)]
        public string CutLayer { get; set; }

        /// <summary>
        /// (Deprecated) PDF layer name used to define crease lines in the artwork
        /// </summary>
        /// <value>(Deprecated) PDF layer name used to define crease lines in the artwork</value>
        [DataMember(Name="crease-layer", EmitDefaultValue=false)]
        public string CreaseLayer { get; set; }

        /// <summary>
        /// (Deprecated) PDF layer name used to define bleed lines in the artwork
        /// </summary>
        /// <value>(Deprecated) PDF layer name used to define bleed lines in the artwork</value>
        [DataMember(Name="bleed-layer", EmitDefaultValue=false)]
        public string BleedLayer { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class AddProductEntity {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Color: ").Append(Color).Append("\n");
            sb.Append("  Ordered: ").Append(Ordered).Append("\n");
            sb.Append("  Stock: ").Append(Stock).Append("\n");
            sb.Append("  Grade: ").Append(Grade).Append("\n");
            sb.Append("  Colors: ").Append(Colors).Append("\n");
            sb.Append("  BackColors: ").Append(BackColors).Append("\n");
            sb.Append("  ColorSource: ").Append(ColorSource).Append("\n");
            sb.Append("  Grain: ").Append(Grain).Append("\n");
            sb.Append("  Width: ").Append(Width).Append("\n");
            sb.Append("  Height: ").Append(Height).Append("\n");
            sb.Append("  Rotation: ").Append(Rotation).Append("\n");
            sb.Append("  AllowedRotations: ").Append(AllowedRotations).Append("\n");
            sb.Append("  Templates: ").Append(Templates).Append("\n");
            sb.Append("  ScaleProportionally: ").Append(ScaleProportionally).Append("\n");
            sb.Append("  Artwork: ").Append(Artwork).Append("\n");
            sb.Append("  Page: ").Append(Page).Append("\n");
            sb.Append("  BackArtwork: ").Append(BackArtwork).Append("\n");
            sb.Append("  BackPage: ").Append(BackPage).Append("\n");
            sb.Append("  DieshapeSource: ").Append(DieshapeSource).Append("\n");
            sb.Append("  DieDesign: ").Append(DieDesign).Append("\n");
            sb.Append("  AutosnapInk: ").Append(AutosnapInk).Append("\n");
            sb.Append("  BackAutosnapInk: ").Append(BackAutosnapInk).Append("\n");
            sb.Append("  AutosnapLayer: ").Append(AutosnapLayer).Append("\n");
            sb.Append("  BackAutosnapLayer: ").Append(BackAutosnapLayer).Append("\n");
            sb.Append("  ShapeHandling: ").Append(ShapeHandling).Append("\n");
            sb.Append("  PageHandling: ").Append(PageHandling).Append("\n");
            sb.Append("  FrontToBack: ").Append(FrontToBack).Append("\n");
            sb.Append("  CadFile: ").Append(CadFile).Append("\n");
            sb.Append("  CadDesign: ").Append(CadDesign).Append("\n");
            sb.Append("  Group: ").Append(Group).Append("\n");
            sb.Append("  Priority: ").Append(Priority).Append("\n");
            sb.Append("  DueDate: ").Append(DueDate).Append("\n");
            sb.Append("  BleedType: ").Append(BleedType).Append("\n");
            sb.Append("  BleedMargin: ").Append(BleedMargin).Append("\n");
            sb.Append("  BleedMargins: ").Append(BleedMargins).Append("\n");
            sb.Append("  PageBleed: ").Append(PageBleed).Append("\n");
            sb.Append("  SpacingType: ").Append(SpacingType).Append("\n");
            sb.Append("  SpacingMargin: ").Append(SpacingMargin).Append("\n");
            sb.Append("  SpacingMargins: ").Append(SpacingMargins).Append("\n");
            sb.Append("  OffcutMargins: ").Append(OffcutMargins).Append("\n");
            sb.Append("  MinOverruns: ").Append(MinOverruns).Append("\n");
            sb.Append("  MaxOverruns: ").Append(MaxOverruns).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Notes: ").Append(Notes).Append("\n");
            sb.Append("  ProcessSettings: ").Append(ProcessSettings).Append("\n");
            sb.Append("  Marks: ").Append(Marks).Append("\n");
            sb.Append("  BackMarks: ").Append(BackMarks).Append("\n");
            sb.Append("  FoldingPatterns: ").Append(FoldingPatterns).Append("\n");
            sb.Append("  BindingMethod: ").Append(BindingMethod).Append("\n");
            sb.Append("  BindingEdge: ").Append(BindingEdge).Append("\n");
            sb.Append("  JogEdge: ").Append(JogEdge).Append("\n");
            sb.Append("  ReadingOrder: ").Append(ReadingOrder).Append("\n");
            sb.Append("  Pages: ").Append(Pages).Append("\n");
            sb.Append("  PagesPerSection: ").Append(PagesPerSection).Append("\n");
            sb.Append("  SelfCover: ").Append(SelfCover).Append("\n");
            sb.Append("  Trim: ").Append(Trim).Append("\n");
            sb.Append("  NUp: ").Append(NUp).Append("\n");
            sb.Append("  Creep: ").Append(Creep).Append("\n");
            sb.Append("  BundleSize: ").Append(BundleSize).Append("\n");
            sb.Append("  Properties: ").Append(Properties).Append("\n");
            sb.Append("  Tiling: ").Append(Tiling).Append("\n");
            sb.Append("  FrontInks: ").Append(FrontInks).Append("\n");
            sb.Append("  BackInks: ").Append(BackInks).Append("\n");
            sb.Append("  CutInk: ").Append(CutInk).Append("\n");
            sb.Append("  CreaseInk: ").Append(CreaseInk).Append("\n");
            sb.Append("  BleedInk: ").Append(BleedInk).Append("\n");
            sb.Append("  CutLayer: ").Append(CutLayer).Append("\n");
            sb.Append("  CreaseLayer: ").Append(CreaseLayer).Append("\n");
            sb.Append("  BleedLayer: ").Append(BleedLayer).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as AddProductEntity);
        }

        /// <summary>
        /// Returns true if AddProductEntity instances are equal
        /// </summary>
        /// <param name="input">Instance of AddProductEntity to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(AddProductEntity input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.Color == input.Color ||
                    (this.Color != null &&
                    this.Color.Equals(input.Color))
                ) && 
                (
                    this.Ordered == input.Ordered ||
                    (this.Ordered != null &&
                    this.Ordered.Equals(input.Ordered))
                ) && 
                (
                    this.Stock == input.Stock ||
                    (this.Stock != null &&
                    this.Stock.Equals(input.Stock))
                ) && 
                (
                    this.Grade == input.Grade ||
                    (this.Grade != null &&
                    this.Grade.Equals(input.Grade))
                ) && 
                (
                    this.Colors == input.Colors ||
                    this.Colors != null &&
                    input.Colors != null &&
                    this.Colors.SequenceEqual(input.Colors)
                ) && 
                (
                    this.BackColors == input.BackColors ||
                    this.BackColors != null &&
                    input.BackColors != null &&
                    this.BackColors.SequenceEqual(input.BackColors)
                ) && 
                (
                    this.ColorSource == input.ColorSource ||
                    (this.ColorSource != null &&
                    this.ColorSource.Equals(input.ColorSource))
                ) && 
                (
                    this.Grain == input.Grain ||
                    (this.Grain != null &&
                    this.Grain.Equals(input.Grain))
                ) && 
                (
                    this.Width == input.Width ||
                    (this.Width != null &&
                    this.Width.Equals(input.Width))
                ) && 
                (
                    this.Height == input.Height ||
                    (this.Height != null &&
                    this.Height.Equals(input.Height))
                ) && 
                (
                    this.Rotation == input.Rotation ||
                    (this.Rotation != null &&
                    this.Rotation.Equals(input.Rotation))
                ) && 
                (
                    this.AllowedRotations == input.AllowedRotations ||
                    (this.AllowedRotations != null &&
                    this.AllowedRotations.Equals(input.AllowedRotations))
                ) && 
                (
                    this.Templates == input.Templates ||
                    this.Templates != null &&
                    input.Templates != null &&
                    this.Templates.SequenceEqual(input.Templates)
                ) && 
                (
                    this.ScaleProportionally == input.ScaleProportionally ||
                    (this.ScaleProportionally != null &&
                    this.ScaleProportionally.Equals(input.ScaleProportionally))
                ) && 
                (
                    this.Artwork == input.Artwork ||
                    (this.Artwork != null &&
                    this.Artwork.Equals(input.Artwork))
                ) && 
                (
                    this.Page == input.Page ||
                    (this.Page != null &&
                    this.Page.Equals(input.Page))
                ) && 
                (
                    this.BackArtwork == input.BackArtwork ||
                    (this.BackArtwork != null &&
                    this.BackArtwork.Equals(input.BackArtwork))
                ) && 
                (
                    this.BackPage == input.BackPage ||
                    (this.BackPage != null &&
                    this.BackPage.Equals(input.BackPage))
                ) && 
                (
                    this.DieshapeSource == input.DieshapeSource ||
                    (this.DieshapeSource != null &&
                    this.DieshapeSource.Equals(input.DieshapeSource))
                ) && 
                (
                    this.DieDesign == input.DieDesign ||
                    (this.DieDesign != null &&
                    this.DieDesign.Equals(input.DieDesign))
                ) && 
                (
                    this.AutosnapInk == input.AutosnapInk ||
                    (this.AutosnapInk != null &&
                    this.AutosnapInk.Equals(input.AutosnapInk))
                ) && 
                (
                    this.BackAutosnapInk == input.BackAutosnapInk ||
                    (this.BackAutosnapInk != null &&
                    this.BackAutosnapInk.Equals(input.BackAutosnapInk))
                ) && 
                (
                    this.AutosnapLayer == input.AutosnapLayer ||
                    (this.AutosnapLayer != null &&
                    this.AutosnapLayer.Equals(input.AutosnapLayer))
                ) && 
                (
                    this.BackAutosnapLayer == input.BackAutosnapLayer ||
                    (this.BackAutosnapLayer != null &&
                    this.BackAutosnapLayer.Equals(input.BackAutosnapLayer))
                ) && 
                (
                    this.ShapeHandling == input.ShapeHandling ||
                    (this.ShapeHandling != null &&
                    this.ShapeHandling.Equals(input.ShapeHandling))
                ) && 
                (
                    this.PageHandling == input.PageHandling ||
                    (this.PageHandling != null &&
                    this.PageHandling.Equals(input.PageHandling))
                ) && 
                (
                    this.FrontToBack == input.FrontToBack ||
                    (this.FrontToBack != null &&
                    this.FrontToBack.Equals(input.FrontToBack))
                ) && 
                (
                    this.CadFile == input.CadFile ||
                    (this.CadFile != null &&
                    this.CadFile.Equals(input.CadFile))
                ) && 
                (
                    this.CadDesign == input.CadDesign ||
                    (this.CadDesign != null &&
                    this.CadDesign.Equals(input.CadDesign))
                ) && 
                (
                    this.Group == input.Group ||
                    (this.Group != null &&
                    this.Group.Equals(input.Group))
                ) && 
                (
                    this.Priority == input.Priority ||
                    (this.Priority != null &&
                    this.Priority.Equals(input.Priority))
                ) && 
                (
                    this.DueDate == input.DueDate ||
                    (this.DueDate != null &&
                    this.DueDate.Equals(input.DueDate))
                ) && 
                (
                    this.BleedType == input.BleedType ||
                    (this.BleedType != null &&
                    this.BleedType.Equals(input.BleedType))
                ) && 
                (
                    this.BleedMargin == input.BleedMargin ||
                    (this.BleedMargin != null &&
                    this.BleedMargin.Equals(input.BleedMargin))
                ) && 
                (
                    this.BleedMargins == input.BleedMargins ||
                    (this.BleedMargins != null &&
                    this.BleedMargins.Equals(input.BleedMargins))
                ) && 
                (
                    this.PageBleed == input.PageBleed ||
                    (this.PageBleed != null &&
                    this.PageBleed.Equals(input.PageBleed))
                ) && 
                (
                    this.SpacingType == input.SpacingType ||
                    (this.SpacingType != null &&
                    this.SpacingType.Equals(input.SpacingType))
                ) && 
                (
                    this.SpacingMargin == input.SpacingMargin ||
                    (this.SpacingMargin != null &&
                    this.SpacingMargin.Equals(input.SpacingMargin))
                ) && 
                (
                    this.SpacingMargins == input.SpacingMargins ||
                    (this.SpacingMargins != null &&
                    this.SpacingMargins.Equals(input.SpacingMargins))
                ) && 
                (
                    this.OffcutMargins == input.OffcutMargins ||
                    (this.OffcutMargins != null &&
                    this.OffcutMargins.Equals(input.OffcutMargins))
                ) && 
                (
                    this.MinOverruns == input.MinOverruns ||
                    (this.MinOverruns != null &&
                    this.MinOverruns.Equals(input.MinOverruns))
                ) && 
                (
                    this.MaxOverruns == input.MaxOverruns ||
                    (this.MaxOverruns != null &&
                    this.MaxOverruns.Equals(input.MaxOverruns))
                ) && 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.Notes == input.Notes ||
                    (this.Notes != null &&
                    this.Notes.Equals(input.Notes))
                ) && 
                (
                    this.ProcessSettings == input.ProcessSettings ||
                    this.ProcessSettings != null &&
                    input.ProcessSettings != null &&
                    this.ProcessSettings.SequenceEqual(input.ProcessSettings)
                ) && 
                (
                    this.Marks == input.Marks ||
                    this.Marks != null &&
                    input.Marks != null &&
                    this.Marks.SequenceEqual(input.Marks)
                ) && 
                (
                    this.BackMarks == input.BackMarks ||
                    this.BackMarks != null &&
                    input.BackMarks != null &&
                    this.BackMarks.SequenceEqual(input.BackMarks)
                ) && 
                (
                    this.FoldingPatterns == input.FoldingPatterns ||
                    this.FoldingPatterns != null &&
                    input.FoldingPatterns != null &&
                    this.FoldingPatterns.SequenceEqual(input.FoldingPatterns)
                ) && 
                (
                    this.BindingMethod == input.BindingMethod ||
                    (this.BindingMethod != null &&
                    this.BindingMethod.Equals(input.BindingMethod))
                ) && 
                (
                    this.BindingEdge == input.BindingEdge ||
                    (this.BindingEdge != null &&
                    this.BindingEdge.Equals(input.BindingEdge))
                ) && 
                (
                    this.JogEdge == input.JogEdge ||
                    (this.JogEdge != null &&
                    this.JogEdge.Equals(input.JogEdge))
                ) && 
                (
                    this.ReadingOrder == input.ReadingOrder ||
                    (this.ReadingOrder != null &&
                    this.ReadingOrder.Equals(input.ReadingOrder))
                ) && 
                (
                    this.Pages == input.Pages ||
                    (this.Pages != null &&
                    this.Pages.Equals(input.Pages))
                ) && 
                (
                    this.PagesPerSection == input.PagesPerSection ||
                    (this.PagesPerSection != null &&
                    this.PagesPerSection.Equals(input.PagesPerSection))
                ) && 
                (
                    this.SelfCover == input.SelfCover ||
                    (this.SelfCover != null &&
                    this.SelfCover.Equals(input.SelfCover))
                ) && 
                (
                    this.Trim == input.Trim ||
                    (this.Trim != null &&
                    this.Trim.Equals(input.Trim))
                ) && 
                (
                    this.NUp == input.NUp ||
                    (this.NUp != null &&
                    this.NUp.Equals(input.NUp))
                ) && 
                (
                    this.Creep == input.Creep ||
                    (this.Creep != null &&
                    this.Creep.Equals(input.Creep))
                ) && 
                (
                    this.BundleSize == input.BundleSize ||
                    (this.BundleSize != null &&
                    this.BundleSize.Equals(input.BundleSize))
                ) && 
                (
                    this.Properties == input.Properties ||
                    this.Properties != null &&
                    input.Properties != null &&
                    this.Properties.SequenceEqual(input.Properties)
                ) && 
                (
                    this.Tiling == input.Tiling ||
                    (this.Tiling != null &&
                    this.Tiling.Equals(input.Tiling))
                ) && 
                (
                    this.FrontInks == input.FrontInks ||
                    this.FrontInks != null &&
                    input.FrontInks != null &&
                    this.FrontInks.SequenceEqual(input.FrontInks)
                ) && 
                (
                    this.BackInks == input.BackInks ||
                    this.BackInks != null &&
                    input.BackInks != null &&
                    this.BackInks.SequenceEqual(input.BackInks)
                ) && 
                (
                    this.CutInk == input.CutInk ||
                    (this.CutInk != null &&
                    this.CutInk.Equals(input.CutInk))
                ) && 
                (
                    this.CreaseInk == input.CreaseInk ||
                    (this.CreaseInk != null &&
                    this.CreaseInk.Equals(input.CreaseInk))
                ) && 
                (
                    this.BleedInk == input.BleedInk ||
                    (this.BleedInk != null &&
                    this.BleedInk.Equals(input.BleedInk))
                ) && 
                (
                    this.CutLayer == input.CutLayer ||
                    (this.CutLayer != null &&
                    this.CutLayer.Equals(input.CutLayer))
                ) && 
                (
                    this.CreaseLayer == input.CreaseLayer ||
                    (this.CreaseLayer != null &&
                    this.CreaseLayer.Equals(input.CreaseLayer))
                ) && 
                (
                    this.BleedLayer == input.BleedLayer ||
                    (this.BleedLayer != null &&
                    this.BleedLayer.Equals(input.BleedLayer))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.Color != null)
                    hashCode = hashCode * 59 + this.Color.GetHashCode();
                if (this.Ordered != null)
                    hashCode = hashCode * 59 + this.Ordered.GetHashCode();
                if (this.Stock != null)
                    hashCode = hashCode * 59 + this.Stock.GetHashCode();
                if (this.Grade != null)
                    hashCode = hashCode * 59 + this.Grade.GetHashCode();
                if (this.Colors != null)
                    hashCode = hashCode * 59 + this.Colors.GetHashCode();
                if (this.BackColors != null)
                    hashCode = hashCode * 59 + this.BackColors.GetHashCode();
                if (this.ColorSource != null)
                    hashCode = hashCode * 59 + this.ColorSource.GetHashCode();
                if (this.Grain != null)
                    hashCode = hashCode * 59 + this.Grain.GetHashCode();
                if (this.Width != null)
                    hashCode = hashCode * 59 + this.Width.GetHashCode();
                if (this.Height != null)
                    hashCode = hashCode * 59 + this.Height.GetHashCode();
                if (this.Rotation != null)
                    hashCode = hashCode * 59 + this.Rotation.GetHashCode();
                if (this.AllowedRotations != null)
                    hashCode = hashCode * 59 + this.AllowedRotations.GetHashCode();
                if (this.Templates != null)
                    hashCode = hashCode * 59 + this.Templates.GetHashCode();
                if (this.ScaleProportionally != null)
                    hashCode = hashCode * 59 + this.ScaleProportionally.GetHashCode();
                if (this.Artwork != null)
                    hashCode = hashCode * 59 + this.Artwork.GetHashCode();
                if (this.Page != null)
                    hashCode = hashCode * 59 + this.Page.GetHashCode();
                if (this.BackArtwork != null)
                    hashCode = hashCode * 59 + this.BackArtwork.GetHashCode();
                if (this.BackPage != null)
                    hashCode = hashCode * 59 + this.BackPage.GetHashCode();
                if (this.DieshapeSource != null)
                    hashCode = hashCode * 59 + this.DieshapeSource.GetHashCode();
                if (this.DieDesign != null)
                    hashCode = hashCode * 59 + this.DieDesign.GetHashCode();
                if (this.AutosnapInk != null)
                    hashCode = hashCode * 59 + this.AutosnapInk.GetHashCode();
                if (this.BackAutosnapInk != null)
                    hashCode = hashCode * 59 + this.BackAutosnapInk.GetHashCode();
                if (this.AutosnapLayer != null)
                    hashCode = hashCode * 59 + this.AutosnapLayer.GetHashCode();
                if (this.BackAutosnapLayer != null)
                    hashCode = hashCode * 59 + this.BackAutosnapLayer.GetHashCode();
                if (this.ShapeHandling != null)
                    hashCode = hashCode * 59 + this.ShapeHandling.GetHashCode();
                if (this.PageHandling != null)
                    hashCode = hashCode * 59 + this.PageHandling.GetHashCode();
                if (this.FrontToBack != null)
                    hashCode = hashCode * 59 + this.FrontToBack.GetHashCode();
                if (this.CadFile != null)
                    hashCode = hashCode * 59 + this.CadFile.GetHashCode();
                if (this.CadDesign != null)
                    hashCode = hashCode * 59 + this.CadDesign.GetHashCode();
                if (this.Group != null)
                    hashCode = hashCode * 59 + this.Group.GetHashCode();
                if (this.Priority != null)
                    hashCode = hashCode * 59 + this.Priority.GetHashCode();
                if (this.DueDate != null)
                    hashCode = hashCode * 59 + this.DueDate.GetHashCode();
                if (this.BleedType != null)
                    hashCode = hashCode * 59 + this.BleedType.GetHashCode();
                if (this.BleedMargin != null)
                    hashCode = hashCode * 59 + this.BleedMargin.GetHashCode();
                if (this.BleedMargins != null)
                    hashCode = hashCode * 59 + this.BleedMargins.GetHashCode();
                if (this.PageBleed != null)
                    hashCode = hashCode * 59 + this.PageBleed.GetHashCode();
                if (this.SpacingType != null)
                    hashCode = hashCode * 59 + this.SpacingType.GetHashCode();
                if (this.SpacingMargin != null)
                    hashCode = hashCode * 59 + this.SpacingMargin.GetHashCode();
                if (this.SpacingMargins != null)
                    hashCode = hashCode * 59 + this.SpacingMargins.GetHashCode();
                if (this.OffcutMargins != null)
                    hashCode = hashCode * 59 + this.OffcutMargins.GetHashCode();
                if (this.MinOverruns != null)
                    hashCode = hashCode * 59 + this.MinOverruns.GetHashCode();
                if (this.MaxOverruns != null)
                    hashCode = hashCode * 59 + this.MaxOverruns.GetHashCode();
                if (this.Description != null)
                    hashCode = hashCode * 59 + this.Description.GetHashCode();
                if (this.Notes != null)
                    hashCode = hashCode * 59 + this.Notes.GetHashCode();
                if (this.ProcessSettings != null)
                    hashCode = hashCode * 59 + this.ProcessSettings.GetHashCode();
                if (this.Marks != null)
                    hashCode = hashCode * 59 + this.Marks.GetHashCode();
                if (this.BackMarks != null)
                    hashCode = hashCode * 59 + this.BackMarks.GetHashCode();
                if (this.FoldingPatterns != null)
                    hashCode = hashCode * 59 + this.FoldingPatterns.GetHashCode();
                if (this.BindingMethod != null)
                    hashCode = hashCode * 59 + this.BindingMethod.GetHashCode();
                if (this.BindingEdge != null)
                    hashCode = hashCode * 59 + this.BindingEdge.GetHashCode();
                if (this.JogEdge != null)
                    hashCode = hashCode * 59 + this.JogEdge.GetHashCode();
                if (this.ReadingOrder != null)
                    hashCode = hashCode * 59 + this.ReadingOrder.GetHashCode();
                if (this.Pages != null)
                    hashCode = hashCode * 59 + this.Pages.GetHashCode();
                if (this.PagesPerSection != null)
                    hashCode = hashCode * 59 + this.PagesPerSection.GetHashCode();
                if (this.SelfCover != null)
                    hashCode = hashCode * 59 + this.SelfCover.GetHashCode();
                if (this.Trim != null)
                    hashCode = hashCode * 59 + this.Trim.GetHashCode();
                if (this.NUp != null)
                    hashCode = hashCode * 59 + this.NUp.GetHashCode();
                if (this.Creep != null)
                    hashCode = hashCode * 59 + this.Creep.GetHashCode();
                if (this.BundleSize != null)
                    hashCode = hashCode * 59 + this.BundleSize.GetHashCode();
                if (this.Properties != null)
                    hashCode = hashCode * 59 + this.Properties.GetHashCode();
                if (this.Tiling != null)
                    hashCode = hashCode * 59 + this.Tiling.GetHashCode();
                if (this.FrontInks != null)
                    hashCode = hashCode * 59 + this.FrontInks.GetHashCode();
                if (this.BackInks != null)
                    hashCode = hashCode * 59 + this.BackInks.GetHashCode();
                if (this.CutInk != null)
                    hashCode = hashCode * 59 + this.CutInk.GetHashCode();
                if (this.CreaseInk != null)
                    hashCode = hashCode * 59 + this.CreaseInk.GetHashCode();
                if (this.BleedInk != null)
                    hashCode = hashCode * 59 + this.BleedInk.GetHashCode();
                if (this.CutLayer != null)
                    hashCode = hashCode * 59 + this.CutLayer.GetHashCode();
                if (this.CreaseLayer != null)
                    hashCode = hashCode * 59 + this.CreaseLayer.GetHashCode();
                if (this.BleedLayer != null)
                    hashCode = hashCode * 59 + this.BleedLayer.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
